####################################
# loading all packages here
###############
# if any of them is not installed on your current device, run
# using Pkg
# and then install like
# Pkg.add("Distributions")

using Distributions
using Parameters
using Interpolations
using Roots
using LinearAlgebra
using Optim

function crra_utility(c,γ)
    if c <= 0 
        throw(DomainError("consumption has to be positive with CRRA utility"))
    else
        if γ < 0
            throw(DomainError("γ has to be positive"))
        elseif γ == 1 # when γ is 1 and hence the usual formula is not well-defined, CRRA simplifies to log utility. Can prove using the Hopital-rule.
            return log(c)
        else
            return (c^(1-γ))/(1 - γ) # usual formula for CRRA
        end
    end    
end

function crra_utility_function(γ)
    return c -> crra_utility(c,γ) # returns a function, which to any consumption level, assigns the corresponding CRRA utility under risk aversion equal to γ
end

"""
This structure stores all parameters describing preferences and the economic environment
"""
@with_kw struct EconPars{S<:AbstractFloat}
    "entreprenurial ability"
    θs::Vector{S} = [0.0, 0.89] # [0.0, 0.514] replaced the authors' figures
    "transition matrix for entreprenurial ability"
    θmat::Array{S,2} = [0.964 0.036;
        0.206 0.794]
    "income process"
    ys::Vector{S} = [0.2468, 0.4473, 0.7654, 1.3097, 2.3742]
    "transition matrix for income process"
    ymat::Array{S,2} = [0.7376 0.2472 0.015 0.0002 0.0;
        0.1947 0.5555 0.2328 0.0169 0.0001;
        0.0113 0.2221 0.5332 0.2221 0.0113;
        0.0001 0.0169 0.2328 0.5555 0.1947;
        0.0 0.0002 0.015 0.2472 0.7376]
    "discount factor"
    β::S = 0.8113
    "risk aversion of used CRRA utility function"
    γ::S = 1.5
    "depreciation rate"
    δ::S = 0.06
    "capital share in non-entreprenurial sector"
    α::S = 0.33
    "survival proability of the young"
    π_y::S = 0.978
    "survival proability of the old"
    π_o::S = 0.911
    "pension"
    p_ratio::S = 0.4
    "bequest motive"
    η::S = 1.0
    "concavity in production function of entrepreneurs"
    ν::S = 0.82 # 0.88 repalced authors' figure
    "share of capital one can run away with"
    f::S = 0.75
end


"""
This structure stores all numerical parameters needed to solve the model
"""
@with_kw struct NumPars{S<:AbstractFloat,T<:Integer}
    "maximum of asset grid"
    max_asset::S = 600.0
    "number of points on asset grid"
    N_asset::T = 150
    "curvature of asset grid. 1 means linear, higher number is more dense around 0"
    grid_curvature::S = 2.0
end

"""
This structure stores the solution, ie the value and optimal policy function of agents in every possible discrete state 

- vf is value function, cp is consumption policy, sp is saving policy, kp is entreprenurial capital policy.

- Y stands for is young, R is retired, O is an old entrepreneur (i.e. an old person who hasn't lost their θ ability)

vfY, cpY, spY, kpY are two dimensional arrays of interpolated functions. For example, cpY[θi, yi] is the optimal consumption policy function of young agents with the θith entrepreneurship ability level, and yith income level. cpY[θi, yi](0.8) would give us the optimal consumption choice of such a person with 0.8 beginning-of-period savings.

vfO, cpO, spO, kpO are one dimensional arrays of interpolated functions. This is because old people don't have a labor income productivity state. For example, cpO[θi] is the optimal consumption policy function of old entrepreneurs with the θith entrepreneurship ability level. cpO[θi](0.8) would give us the optimal consumption choice of such a person with 0.8 beginning-of-period savings.

vfR, cpR, spR are interpolated functions. This is because retired old people don't have neither labor income nor entreprenurial productivity states. For example, cpR is the optimal consumption policy function of retired old agents. cpR(0.8) would give us the optimal consumption choice of such a person with 0.8 beginning-of-period savings. As it is constant 0, we don't save the kp of retired agents.
"""
struct Solution{S<:AbstractArray}
    "value functions"
    vfY::Array{S,2} # an array of some type which is a subtype is AbstractArray (which includes the interpolated function thing generated by Interpolations) 
    "optimal consumption policies"
    cpY::Array{S,2}
    "optimal saving policies"
    spY::Array{S,2}
    "optimal capital policies"
    kpY::Array{S,2}
    "value functions"
    vfO::Array{S,1}
    "optimal consumption policies"
    cpO::Array{S,1}
    "optimal saving policies"
    spO::Array{S,1}
    "optimal capital policies"
    kpO::Array{S,1}
    "value functions"
    vfR::S
    "optimal consumption policies"
    cpR::S
    "optimal saving policies"
    spR::S
end

"""
Solves Cagetti Denardi (2006)
# Arguments:
 - economic parameters
 - numerical parameters
 - a guess for return r
 - a guess for labor income tax τ_l
# Return a Solution structure with the value function and optimal consumption and saving policies.
"""
function solve(ep::EconPars, np::NumPars, r::Real, τ_l::Real, τ_k::Real, τ_w::Real, b::Real; conv_tol=0.0001, maxiter=500)
    @unpack_EconPars ep
    @unpack_NumPars np

    w = (1 - α) * ((r - δ) / α)^(α / (α - 1)) # Wage level is implied by parameters and the guess for r, thanks to Cobb-Douglas. Can be derived from F_K = r-δ and F_L = w and rearranging. 

    p = w*p_ratio # pension is wage level times the replecament ratio

    invd_y = eigen(ymat').vectors[:, end]
    invd_y = invd_y / sum(invd_y) # probabilities of y states in stationary distribution (used for agents being born)

    invd_θ = eigen(θmat').vectors[:, end]
    invd_θ = invd_θ / sum(invd_θ) # probabilities of theta states in stationary distribution (used for agents being born when parent was retired)

    tiny = 10^-7 # very small number that we sometimes add to lowest grid point, to avoid getting -infinities.

    u = crra_utility_function(γ) # this code works for crra utility only

    assetgrid = max_asset .* range(tiny, 1, length=N_asset) .^ grid_curvature # grid for a. NOT a grid for cash-on-hand, since we are following the paper. not evenly spaced anymore! More dense on the bottom 

    # setting initial guesses for policies and the value function. In this case, we choose the policies of eating everything and saving nothing as a starting point. Therefore our guess for the value function will equal the utility from eating everything. We assume old entrepreneurs retire immediately and young people don't enterprise.

    cpR_guess = linear_interpolation(assetgrid, (1 + r) .* assetgrid .+ p, extrapolation_bc=Linear()) # interpolate identity function: for any cash-on-hand level, you eat it all.
    spR_guess = linear_interpolation(assetgrid, fill(0.0, N_asset), extrapolation_bc=Linear()) # interpolate 0: for any cash-on-hand level, you save nothing.
    vfR_guess = linear_interpolation(assetgrid, u.((1 + r) .* assetgrid .+ p), extrapolation_bc=Linear()) # since you eat everything, value = u

    cpO_guess = [linear_interpolation(assetgrid, (1 + r) .* assetgrid .+ p, extrapolation_bc=Linear()) for θi in eachindex(θs)]
    spO_guess = [linear_interpolation(assetgrid, fill(0.0, N_asset), extrapolation_bc=Linear()) for θi in eachindex(θs)]
    vfO_guess = [linear_interpolation(assetgrid, u.((1 + r) .* assetgrid .+ p), extrapolation_bc=Linear()) for θi in eachindex(θs)]
    kpO_guess = [linear_interpolation(assetgrid, fill(0.0, N_asset), extrapolation_bc=Linear()) for θi in eachindex(θs)]

    cpY_guess = [linear_interpolation(assetgrid, (1 + r) .* assetgrid .+ ys[yi] * w * (1 - τ_l), extrapolation_bc=Linear()) for θi in eachindex(θs), yi in eachindex(ys)]
    spY_guess = [linear_interpolation(assetgrid, fill(0.0, N_asset), extrapolation_bc=Linear()) for θi in eachindex(θs), yi in eachindex(ys)]
    vfY_guess = [linear_interpolation(assetgrid, u.((1 + r) .* assetgrid .+ ys[yi] * w * (1 - τ_l)), extrapolation_bc=Linear()) for θi in eachindex(θs), yi in eachindex(ys)]
    kpY_guess = [linear_interpolation(assetgrid, fill(0.0, N_asset), extrapolation_bc=Linear()) for θi in eachindex(θs), yi in eachindex(ys)]

    # initialize the new policies. it doesn't matter what they are, so I just copied the guesses
    cpR_new = deepcopy(cpR_guess)
    spR_new = deepcopy(spR_guess)
    vfR_new = deepcopy(vfR_guess)
    cpO_new = deepcopy(cpO_guess)
    spO_new = deepcopy(spO_guess)
    vfO_new = deepcopy(vfO_guess)
    kpO_new = deepcopy(kpO_guess)
    cpY_new = deepcopy(cpY_guess)
    spY_new = deepcopy(spY_guess)
    vfY_new = deepcopy(vfY_guess)
    kpY_new = deepcopy(kpY_guess)
    # 'deepcopy' is like 'copy', but works even for complicated objects, like interpolated functions.

    # optimal level of entreprenurial capital in the absence of borrowing limits
    # one level for each theta level: for 0 it is 0, for the positive value it can be derived my maxizing private firm output with respect to k
    optks = [0.0, ((r + δ) / (ν * θs[2]))^(1 / (ν - 1))]

    # borrowing limits for entrepreneurs
    # initialize at optimal capital level (i.e. no limit)
    # will be updated after each iteration
    kmaxO = [optks[θi] for _ in 1:N_asset, θi in eachindex(θs)]
    kmaxY = [optks[θi] for _ in 1:N_asset, θi in eachindex(θs), yi in eachindex(ys)]

    # initialize differences from previous policies
    difRc = 100.0
    difRv = 100.0

    difOc = fill(100.0, length(θs))
    difOv = fill(100.0, length(θs))

    difYc = fill(100.0, length(θs), length(ys))
    difYv = fill(100.0, length(θs), length(ys))

    dif = 100.0
    iter = 1

    while dif > conv_tol && iter < maxiter # run the block below if dif is too big and haven't run more than maxiter times already

        #####
        # 1: retired people
        #####

        #initialize vectors that will hold values and policies corresponding to each grid point. we will overwrite these 0s in the for loop below
        cs = fill(0.0, N_asset) # consumption
        as = fill(0.0, N_asset) # end of period asset
        vs = fill(0.0, N_asset) # value

        Threads.@threads for i in 1:N_asset # i runs through all indices of the possible asset values
        # Threads.@threads lets your computer run separate pieces of code on different cores, if your computer has several cores
            coh = (1 - τ_k) * (r * assetgrid[i]) + (1 - τ_w) * assetgrid[i] + b + p
            function value_if_save_a(a) # define a function that to all candidate for end-of-period savings 'a' assigns the corresponding utility. This is the RHS of the Bellman equation assuming we save 'a'.

                value_now = u(coh - a) # utility from eating everything you don't save
                value_future_alive = vfR_guess(a)
                value_future_dead = 0.0
                for yj in eachindex(ys) # if dies, draw an income state for child
                    for θj in eachindex(θs) # and a theta state too. for both draw from stationary distribution, since skills are forgotten in the case of retired people.
                        value_future_dead += invd_y[yj] * invd_θ[θj] * vfY_guess[θj, yj](a)
                    end
                end
                return value_now + β * π_o * value_future_alive + β * η * (1 - π_o) * value_future_dead
            end

            tominimize(a) = -value_if_save_a(a) # multiply by -1, since optimize minimizes functions
            opt_a = optimize(tominimize, 0, coh).minimizer
            # minimize function 'tomin'
            # - such that savings is above the minimum amount of end-of-period savings
            # - savings is less than cash-on-hand, enabling non-negative consumption
            #   why is this so? a = coh-c, so a<coh is equivalent to c>0. 
            cs[i] = coh - opt_a # consumption is coh - savings
            as[i] = opt_a
            vs[i] = value_if_save_a(opt_a) # we just evaluate the above defined function to get the value corresponding to optimal saving
        end

        # and now we can interpolate the value and policy functions for age t
        cpR_new = linear_interpolation(assetgrid, cs, extrapolation_bc=Linear())
        spR_new = linear_interpolation(assetgrid, as, extrapolation_bc=Linear())
        vfR_new = linear_interpolation(assetgrid, vs, extrapolation_bc=Linear())

        #####
        # 2: old entrepreneur
        #####

        for θi in eachindex(θs) # have to run it for all possible values of θ
            # initialize vectors for the case of choosing to stay as an entrepreneur
            cs_e = fill(0.0, N_asset) # consumption
            as_e = fill(0.0, N_asset) # end of period asset
            ks_e = fill(0.0, N_asset) # entreprenurial capital
            vs_e = fill(0.0, N_asset) # value

            Threads.@threads for i in 1:N_asset 
                k = kmaxO[i, θi] # set k to the maximum allowed level - it is optimal to be either at the borrowing limit, or at the optks level
                coh = (1 - τ_k) * (θs[θi] * k^ν - δ * k - r*(k - assetgrid[i])) + (1 - τ_w) * assetgrid[i] + b
                function value_if_save_a(a)

                    value_now = u(coh - a)
                    value_future_alive = 0.0
                    for θj in eachindex(θs) # take into account possible changes in theta
                        value_future_alive += θmat[θi, θj] * vfO_guess[θj](a)
                    end

                    value_future_dead = 0.0 # when dying
                    for yj in eachindex(ys) # draw from stationary y distribution for child, since labor skills are forgotten 
                        for θj in eachindex(θs) # but theta is not forgotten, so use transition matrix
                            value_future_dead += invd_y[yj] * θmat[θi, θj] * vfY_guess[θj, yj](a)
                        end
                    end
                    return value_now + β * π_o * value_future_alive + β * η * (1 - π_o) * value_future_dead
                end

                tominimize(a) = -value_if_save_a(a) 
                opt_a = optimize(tominimize, 0, coh).minimizer
                cs_e[i] = coh - opt_a
                as_e[i] = opt_a
                ks_e[i] = k
                vs_e[i] = value_if_save_a(opt_a)


                # filling kmaxO
                if vfR_guess(f * optks[θi]) <= vs_e[i] # if even running away with ideal k is a bad idea
                    kmaxO[i, θi] = optks[θi] # then not constrained in this state -> set kmax to the ideal k level
                elseif θs[θi] == 0 || vfR_guess(0) >= vs_e[i] # if no entreprenurial talent, or even being retired with no wealth is better then an enterprise
                    kmaxO[i, θi] = 0.0 # then set kmax to 0
                else # otherwise solve for borrowing limit; will be used in next iteration!
                    kmaxO[i, θi] = find_zero(kstar -> vfR_guess(f * kstar) - vs_e[i], (0, optks[θi])) # find k, such that indifferent about running away.
                end
            end

            # grid not conditional on being an entrepreneur or not

            cs = fill(0.0, N_asset)
            as = fill(0.0, N_asset)
            ks = fill(0.0, N_asset)
            vs = fill(0.0, N_asset)

            for i in 1:N_asset
                if vs_e[i] > vfR_new(assetgrid[i]) #if at this grid point, it is better to the an entrepreneur
                    cs[i] = cs_e[i] # fill grid points with the _e version
                    as[i] = as_e[i]
                    ks[i] = ks_e[i]
                    vs[i] = vs_e[i]
                else # otherwise retire immediately and use optimal policy or the retired.
                    cs[i] = cpR_new(assetgrid[i])
                    as[i] = spR_new(assetgrid[i])
                    ks[i] = 0.0
                    vs[i] = vfR_new(assetgrid[i])
                end
            end

            # now interpoliate optimal policies and value function

            cpO_new[θi] = linear_interpolation(assetgrid, cs, extrapolation_bc=Linear())
            spO_new[θi] = linear_interpolation(assetgrid, as, extrapolation_bc=Linear())
            kpO_new[θi] = linear_interpolation(assetgrid, ks, extrapolation_bc=Linear())
            vfO_new[θi] = linear_interpolation(assetgrid, vs, extrapolation_bc=Linear())

            ################
            # 3) young
            ################
            for yi in eachindex(ys) # have to run this for all possible value of y 
                # conditional on being an entrepreneur this period
                cs_e = fill(0.0, N_asset)
                as_e = fill(0.0, N_asset)
                ks_e = fill(0.0, N_asset)
                vs_e = fill(0.0, N_asset)

                # conditional on being a wage earner this period
                cs_w = fill(0.0, N_asset)
                as_w = fill(0.0, N_asset)
                vs_w = fill(0.0, N_asset)

                Threads.@threads for i in 1:N_asset
                    k = kmaxY[i, θi, yi]
                    # coh if enterprise
                    coh_e = (1 - τ_k) * (θs[θi] * k^ν - δ * k - r*(k - assetgrid[i])) + (1 - τ_w) * assetgrid[i] + b
                    function value_if_save_a_e(a) # value if saving 'a' AND enterprise

                        value_now = u(coh_e - a) 
                        value_future_young = 0.0
                        for yj in eachindex(ys) # draw both shocks from transition matrices, no skills are forgotten
                            for θj in eachindex(θs)
                                value_future_young += θmat[θi, θj] * ymat[yi, yj] * vfY_guess[θj, yj](a)
                            end
                        end

                        value_future_old = 0.0
                        for θj in eachindex(θs) # if gets old, becomes old entrepreneur and relevant skills are correlated
                            value_future_old += θmat[θi, θj] * vfO_guess[θj](a)
                        end
                        return value_now + β * π_y * value_future_young + β * (1 - π_y) * value_future_old
                    end

                    tominimize_e(a) = -value_if_save_a_e(a) 
                    opt_a_e = optimize(tominimize_e, 0, coh_e).minimizer
                    
                    cs_e[i] = coh_e - opt_a_e 
                    as_e[i] = opt_a_e
                    ks_e[i] = k
                    vs_e[i] = value_if_save_a_e(opt_a_e)

                    # coh if being a wage earner
                    coh_w = (1 - τ_k) * (r * assetgrid[i]) + (1 - τ_w) * assetgrid[i] + (1 - τ_l) * w * ys[yi] + b
                    function value_if_save_a_w(a) # value if saving 'a' AND being a wage earner

                        value_now = u(coh_w - a) 

                        value_future_young = 0.0
                        for yj in eachindex(ys)
                            for θj in eachindex(θs)
                                value_future_young += θmat[θi, θj] * ymat[yi, yj] * vfY_guess[θj, yj](a)
                            end
                        end

                        value_future_old = vfR_guess(a) # if gets old, becomes a retired person with no skills
                        return value_now + β * π_y * value_future_young + β * (1 - π_y) * value_future_old
                    end

                    tominimize_w(a) = -value_if_save_a_w(a) 
                    opt_a_w = optimize(tominimize_w, 0, coh_w).minimizer
                    
                    cs_w[i] = coh_w - opt_a_w
                    as_w[i] = opt_a_w
                    vs_w[i] = value_if_save_a_w(opt_a_w)
                end

                # interpolated value if being a wage earner. need it now to know when it is optimal to run away 
                Yv_if_w = linear_interpolation(assetgrid, vs_w, extrapolation_bc=Linear())

                # filling kmaxY
                for i in 1:N_asset
                    if Yv_if_w(f * optks[θi]) <= vs_e[i] 
                        kmaxY[i, θi, yi] = optks[θi] 
                    elseif θs[θi] == 0 || Yv_if_w(0) >= vs_e[i]
                        kmaxY[i, θi, yi] = 0.0
                    else 
                        kmaxY[i, θi, yi] = find_zero(kstar -> Yv_if_w(f * kstar) - vs_e[i], (0, optks[θi]))
                    end
                end

                # grids for unconditional policies and values 

                cs = fill(0.0, N_asset)
                as = fill(0.0, N_asset)
                ks = fill(0.0, N_asset)
                vs = fill(0.0, N_asset)

                for i in 1:N_asset
                    if vs_e[i] > vs_w[i] # if higher value as entrepreneur
                        cs[i] = cs_e[i] # choose _e versions
                        as[i] = as_e[i]
                        ks[i] = ks_e[i]
                        vs[i] = vs_e[i]
                    else # otherwise
                        cs[i] = cs_w[i] # choose _w versions
                        as[i] = as_w[i]
                        ks[i] = 0.0
                        vs[i] = vs_w[i]
                    end
                end

                cpY_new[θi, yi] = linear_interpolation(assetgrid, cs, extrapolation_bc=Linear())
                spY_new[θi, yi] = linear_interpolation(assetgrid, as, extrapolation_bc=Linear())
                kpY_new[θi, yi] = linear_interpolation(assetgrid, ks, extrapolation_bc=Linear())
                vfY_new[θi, yi] = linear_interpolation(assetgrid, vs, extrapolation_bc=Linear())
            end
        end

        #############
        # 4) update policies
        ###############

        # we want to stop when both the consumption policy and the value function converged in all states

        difRc = norm(cpR_new.(assetgrid) ./ cpR_guess.(assetgrid) .- 1, Inf)
        difRv = norm(vfR_new.(assetgrid) ./ vfR_guess.(assetgrid) .- 1, Inf) 
        
        # after computing differences, we can overwrite the old guess with the new one.
        cpR_guess = deepcopy(cpR_new)
        spR_guess = deepcopy(spR_new)
        vfR_guess = deepcopy(vfR_new)

        for θi in eachindex(θs)
            difOc[θi] = norm(cpO_new[θi].(assetgrid) ./ cpO_guess[θi].(assetgrid) .- 1, Inf)
            difOv[θi] = norm(vfO_new[θi].(assetgrid) ./ vfO_guess[θi].(assetgrid) .- 1, Inf)
            cpO_guess[θi] = deepcopy(cpO_new[θi])
            spO_guess[θi] = deepcopy(spO_new[θi])
            kpO_guess[θi] = deepcopy(spO_new[θi])
            vfO_guess[θi] = deepcopy(vfO_new[θi])
            for yi in eachindex(ys)
                difYc[θi, yi] = norm(cpY_new[θi, yi].(assetgrid) ./ cpY_guess[θi, yi].(assetgrid) .- 1, Inf)
                difYv[θi, yi] = norm(vfY_new[θi, yi].(assetgrid) ./ vfY_guess[θi, yi].(assetgrid) .- 1, Inf)
                cpY_guess[θi, yi] = deepcopy(cpY_new[θi, yi])
                spY_guess[θi, yi] = deepcopy(spY_new[θi, yi])
                kpY_guess[θi, yi] = deepcopy(spY_new[θi, yi])
                vfY_guess[θi, yi] = deepcopy(vfY_new[θi, yi])
            end
        end

        dif = difRc + difRv + maximum(difOc) + maximum(difOv) + maximum(difYc) + maximum(difYv) # total difference is the sum of all

        #println("done with iteration $iter, difference was $dif")
        iter += 1
    end
    if dif > conv_tol
        println("didn't converge in $maxiter iterations")
    end
    return Solution(vfY_new, cpY_new, spY_new, kpY_new, vfO_new, cpO_new, spO_new, kpO_new, vfR_new, cpR_new, spR_new)
end

"""
Simulates shocks for Cagetti De Nardi (2006)
# Arguments:
 - economic parameters
 - numerical parameters
 - N: number of dynasties
 - T: number of time-periods

# Returns three NxT matrices:
 - olds: Boolian; true is old, false is young
 - yis: index of y state. 0 means no state (in the case of old people). if yis is yi, then y is ep.ys[yi]
 - θtrans_shocks: shocks following a uniform distribution. used to simulate θis in simulate_rest (we cannot do that directly, since θ depends on entrepreneurship decisions). NOT used for anythings else.
"""
function simulate_shocks(ep::EconPars, np::NumPars, N::Integer, T::Integer)
    @unpack_EconPars ep
    @unpack_NumPars np

    invd_y = eigen(ymat').vectors[:, end]
    invd_y = invd_y / sum(invd_y)
    Dinvd_y = Categorical(invd_y)
    Ds_y = [Categorical(ymat[i, :]) for i in axes(ymat,1)]


    # everybody starts as a young person with middle income state, and first (0) theta state

    yis = fill(3, N, T)
    θtrans_shocks = rand(N, T)
    olds = fill(false, N, T)
    
        for t in 2:T
            for n in 1:N
                if olds[n,t-1] # if old in previous period
                    if rand() > π_o # and dies
                        olds[n,t] = false # reborn as young
                    else
                        olds[n,t] = true # stay old
                    end
                else
                    if rand() > π_y # gets old
                        olds[n,t] = true # becomes old
                    else
                        olds[n,t] = false # stay young
                    end
                end

                if olds[n,t] # if old now
                    yis[n,t] = 0 # no income state
                elseif olds[n,t-1] # old before
                    yis[n,t] = rand(Dinvd_y) # draw income from invariant/stationary distribution
                else
                    yis[n,t] = rand(Ds_y[yis[n,t-1]])  # draw using transition probabilities corresponding to previous state
                end

            end
        
    end

    return (olds, yis, θtrans_shocks)
end

"""
Simulates decisions for Cagetti De Nardi (2006)
# Arguments:
 - economic parameters
 - numerical parameters
 - olds - see simulate_shocks
 - yis - see simulate_shocks
 - θtrans_shocks - see simulate_shocks

# Returns four NxT matrices:
 - θis: index of θ state. 0 means no state (in the case of retired old people). if θis is θi, then θ is ep.θs[θi]
 - ks: entrepreneurial capital. 0 if not an entrepreneur.
 - cs: consumption
 - as: savings, end-of-period assets. same as a' in Cagetti De Nardi (2006)
"""
function simulate_rest(ep::EconPars, np::NumPars, sol::Solution,olds, yis, θtrans_shocks)
    @unpack_EconPars ep
    @unpack_NumPars np

    N = size(olds,1)
    T = size(olds,2)

    invd_θ = eigen(θmat').vectors[:, end]
    invd_θ = invd_θ / sum(invd_θ)

    # everybody starts as a young person with middle income state, and first (0) theta state

    θis = fill(1, N, T)

    ks = fill(0.0, N, T)
    cs = fill(0.0, N, T)
    as = fill(0.0, N, T) # beginning of period assets 

    for n in 1:N
        as[n,2] = sol.spY[1,3](0.0)
    end
    
        for t in 2:T
            for n in 1:N

                if olds[n,t] && ks[n,t-1] == 0.0 # if old now and not an entrepreneur in previous period in previous
                    θis[n,t] = 0 # no entr ability state
                elseif olds[n,t-1] 
                    # draw from invariant/stationary distribution
                    if θtrans_shocks[n,t] > invd_θ[1]
                        θis[n,t] = 2
                    else
                        θis[n,t] = 1
                    end                     
                else
                    # draw using transition probabilities corresponding to previous state
                    if θtrans_shocks[n,t] > θmat[θis[n,t-1], 1]
                        θis[n,t] = 2
                    else
                        θis[n,t] = 1
                    end 
                end

                if olds[n,t]
                    if θis[n,t] == 0
                        ks[n,t] = 0.0
                        cs[n,t] = sol.cpR(as[n,t])
                        if t<T
                            as[n,t+1] = sol.spR(as[n,t])
                        end
                    else
                        θi = θis[n,t]
                        ks[n,t] = sol.kpO[θi](as[n,t])
                        cs[n,t] = sol.cpO[θi](as[n,t])
                        if t<T
                            as[n,t+1] = sol.spO[θi](as[n,t])
                        end
                    end
                else
                    θi = θis[n,t]
                    yi = yis[n,t]
                    ks[n,t] = sol.kpY[θi,yi](as[n,t])
                    cs[n,t] = sol.cpY[θi,yi](as[n,t])
                    if t<T
                        as[n,t+1] = sol.spY[θi,yi](as[n,t])
                    end
                    
                end
            end
        
    end

    return (θis, ks, cs, as)
end

"""
Simulates Cagetti De Nardi (2006)
# Arguments:
 - economic parameters
 - numerical parameters
 - solution
 - N: number of dynasties
 - T: number of time-periods

# Returns six NxT matrices:
 - olds: Boolian; true is old, false is young
 - yis: index of y state. 0 means no state (in the case of old people). if yis is yi, then y is ep.ys[yi]
 - θis: index of θ state. 0 means no state (in the case of retired old people). if θis is θi, then θ is ep.θs[θi]
 - ks: entrepreneurial capital. 0 if not an entrepreneur.
 - cs: consumption
 - as: savings, end-of-period assets. same as a' in Cagetti De Nardi (2006)
"""
function simulate(ep::EconPars, np::NumPars, sol::Solution; N::Integer=10000, T::Integer=1000)
    (olds, yis, θtrans_shocks) = simulate_shocks(ep::EconPars, np::NumPars, N, T)
    (θis, ks, cs, as) = simulate_rest(ep::EconPars, np::NumPars, sol::Solution,olds, yis, θtrans_shocks)
    return (olds, yis, θis, ks, cs, as)
end

"""
Computes deviation from targets, caused by guessed numbers for calibrated parameters
# Arguments:
 - x = [ r , τ_l, ...]
 - economic parameters
 - numerical parameters
 - simulated shocks
 - Tmin: time period before this one are ignored when computing means in simulated data.

# Returns percentage deviations of implied r from guesses, and budget surplus per person relative to wage level
"""
function GE_difference(x,ep::EconPars, np::NumPars, olds, yis, θtrans_shocks, Tmin::Integer = 501)
    @unpack_EconPars ep
    r = x[1]
    τ_l = x[2]
    τ_k = x[3]
    τ_w = x[4]
    b = x[5]
    # println("trying $([r, τ_l])")
    if r <= ep.δ # when trying r < δ, give penalty. this would lead to error in solution, so we don't solve the model with such a bad guess
        return [(ep.δ-r)^5 + 1000, 0]
    end
    sol = solve(ep, np, r, τ_l, τ_k, τ_w, b, maxiter = 150)
    (θis, ks, cs, as) = simulate_rest(ep, np, sol,olds, yis, θtrans_shocks)

    # ignore first Tmin periods
    olds = olds[:,Tmin:end]
    yis = yis[:,Tmin:end]
    θis = θis[:,Tmin:end]
    ks = ks[:,Tmin:end]
    as = as[:,Tmin:end]

    # population size
    N_sample = length(yis)
    
    # imlied by Cobb-Douglas and r
    w = (1 - α) * ((r - δ) / α)^(α / (α - 1))

    pension_total = p_ratio * w * sum(ks .== 0.0 .&& olds) 
    # total pension expenses
    # p_ratio x w x number of pensioners (not entrepreneur AND old)

    y_total = 0.0 # total labor supply
    for i in eachindex(yis)
        if yis[i] != 0 && ks[i] == 0.0 # if not old and not entrepreneur
            y_total += ys[yis[i]]
        end
    end
    earnings_total = y_total * w

    ci = similar(ks) 
    for t in 1:size(ci,2)
        for n in 1:size(ci,1)
            if θis[n,t] == 0 # if not entrepreneur
                ci[n,t] = r * as[n,t]
            else
                ci[n,t] = θs[θis[n,t]] * ks[n,t]^ν - δ * ks[n,t] - r * (ks[n,t] - as[n,t])
            end
        end
    end

    k_total = sum(ci) # total capital income
    w_total = sum(as) # total wealth
    benefits_total = N_sample * b

    # express per capital gov budget balance relative to average labor income.
    budget_balance_relative = (earnings_total*τ_l + k_total*τ_k + w_total*τ_w - pension_total - benefits_total) / (N_sample * w)    

    y_perp = y_total / N_sample # labor supply per person

    K_perp = mean(as) # savings per person = capital per person
    Ke_perp = mean(ks) # capital of entrepreneurs
    Kc_perp = K_perp-Ke_perp # corporate capital

    r_implied = α * (y_perp/Kc_perp)^(1-α) - δ # this r is implied by the simulated capital and labor supply figures, and Cobb-Douglas. should be closed to the r we guessed

    # println("differences are $((r_implied/r-1, budget_balance_relative))")

    return [r_implied/r-1, budget_balance_relative]
end

"""
Solves a system of two equations via nesting two one-dimensional root-finding procedures in each other. Even though super robust, this method is not available in standard Julia libraries, as it is terribly inefficient for higher dimensions. For 2 dimensions it's ok for us.

Arguments:
 - f is a function that takes a 2-element vector and returns a 2-element vector
 - tuple1 is a tuple containing lower of upper bounds for the 1st argument of f
 - tuple2 is a tuple containing lower of upper bounds for the 2st argument of f
 - Keyword arguments atol and xatol control precision.

Returns
 - a two element vector x, where f(x) is approximately [0,0].
"""
function nested_find_zero(f::Function, tuple1::Tuple, tuple2::Tuple; atol::Real = 10^-3, xatol::Real = 10^-5)
    x = [0.0,0.0]
    function solve_for_1st_arg!(x,f,tuple1,atol,xatol)
        x1_root = find_zero(x1 -> f([x1,x[2]])[1], tuple1, Roots.AlefeldPotraShi(), atol = atol, xatol = xatol)
        x[1] = x1_root
    end

    x2_root = find_zero(x2 -> f([solve_for_1st_arg!(setindex!(x,x2,2),f,tuple1,atol,xatol),x2])[2], tuple2, Roots.AlefeldPotraShi(), atol = atol, xatol = xatol)
    x[2] = x2_root
    return x
end

function gini(values::AbstractVector)
    n = length(values)
    A = 0.0
    for i in 1:n
        for j in 1:n
            A += abs(values[i]-values[j])
        end
    end
    B = sum(values)
    return 0.5*A/B/n
end

function share_top(values;perc = 0.01)
    ws = sort(values, rev = true)
    len = length(ws)
    topperc_len = round(Int,len*perc)
    if sum(ws) == 0
        throw(error("Nobody saves in this economy"))
    end
    return sum(ws[1:topperc_len])/sum(ws)
end

function share_at0(values)
    N0 = sum(values .<= 0)
    return N0/length(values)
end